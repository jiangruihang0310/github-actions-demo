<style>
	.outer {
		width: 800px;
		height: 600px;
		border: 1px solid pink;
		margin: 0 auto;
		position: relative;
	}

	.drag-box {
		width: 400px;
		height: 250px;
		position: absolute;
		background-image: url('https://fuss10.elemecdn.com/d/e6/c4d93a3805b3ce3f323f7974e6f78jpeg.jpeg');
		background-size: 100%;
	}
</style>

<div class="outer">
	<div class="drag-box"></div>
</div>

<script>
	var dragBox = document.getElementsByClassName('drag-box')[0]
	var oOuter = document.getElementsByClassName('outer')[0]

	// 是否处于拖拽状态
	var isDragging = false
	// mousedown时，鼠标与dragBox边界的距离
	var distance = { x: 0, y: 0 }

	dragBox.addEventListener('mousedown', function (e) {
		// 记录鼠标与dragBox（即事件源对象）的距离
		distance.x = e.offsetX
		distance.y = e.offsetY

		isDragging = true
	})

	// 值得注意的是，mousemove的事件处理函数，是绑定在document中的，
	// 因为鼠标拖动速度太快时，有那么一瞬间，dragBox是跟不上鼠标的速度，
	// 鼠标会处于dragBox外面，甚至出于outer外面，
	// 所以这个事件处理函数需要由document来绑定
	document.addEventListener('mousemove', function (e) {
		if (!isDragging) return;

		// 可获取outer与可视区域的距离
		var rect = oOuter.getBoundingClientRect()

		// 计算鼠标相对于outer的距离
		var pointToOuterX = e.clientX - rect.left
		var pointToOuterY = e.clientY - rect.top

		// 计算并赋值dragBox相对于outer的left和top
		dragBox.style.left = pointToOuterX - distance.x + 'px'
		dragBox.style.top = pointToOuterY - distance.y + 'px'

		// 上述操作已完成拖拽，下面的操作是防止拖拽的div越过外层盒子
		if (dragBox.offsetLeft < 0) dragBox.style.left = 0;
		if (dragBox.offsetTop < 0) dragBox.style.top = 0;
		// 下面两个判断分别是防止dragBox右边界和上边界越界，可以将代码跑起来理解
		if (dragBox.offsetLeft > (oOuter.offsetWidth - dragBox.offsetWidth)) {
			dragBox.style.left = oOuter.offsetWidth - dragBox.offsetWidth + 'px'
		}
		if (dragBox.offsetTop > (oOuter.offsetHeight - dragBox.offsetHeight)) {
			dragBox.style.top = oOuter.offsetHeight - dragBox.offsetHeight + 'px'
		}

	})

	// 值得注意的是，mouseup的事件处理函数，是绑定在document中的，
	// 因为用户在拖动结束时，鼠标可能会处于outer之外，
	// 所以这个事件处理函数需要由document来绑定
	document.addEventListener('mouseup', function (e) {
		isDragging = false
	})
</script>